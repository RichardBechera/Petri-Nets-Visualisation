# Petri-Nets-Visualisation

# Loading
To choose .dot file to load click button `Browse files`, file dialog pos out, choose .dot file and click open. You will see the preview of file and it's location. You can change the file same way or click okay to proceed next.

# Parsing
To parse .dot file I use parser generated by`antlr`. Parser takes choosen file and returns parsed tree. Next I'm traversing the tree and building up very basic graph with help of my custom listener `KeyPrinter.cs`. Building up the graph I still ignore many features of DOT language, I'm not saving ports, more edges written on one line in format `a->b->c` All parser files are saved in `Parser files` directory, graph, loading and graph building files are saved under `LoadInnerLogic` directory.

# Basic Graph
Each Graph, DotNode and Subgraph are under abstract class IGraph which contains common fields such as their id, list of different attributes and list of successors. Each Subgraph and DotNode has property beloning meaning child of which Graph or Subgraph it is, It's an idea of its parent. Graph has property strict which is boolean, List of each subgraph (either children or grand\*children). Class edge repressents edge between 2 nodes or subgraphs. Each node is saved under it's ID where in case of oriented graph head is just head of an arrow and tail is tail of an arrow, It also has EdgeAttr, List of edge attributes, not used in our program yet.

# Graph we are working with
Here we are using only class Graph, Node and Attributes. Graph contains List of `Node`s in it, List of `Subgraph`s and `Attribute attr`. `_strict` of type boolean if graph is strict and `_type` - enum {Digraph, Graph, Empty}. Class Node containing `Attributes attr`, unused `string port` and List of Tuples (edges) where first Item is node's succesor of type Node and second Item is Dictonary of edge attributes. And finally class `Attributes` with an string id, string belonging from previous Basic graph, and 3 Dictionaries each for Graph attributes, Edge Attribuutes and Node attributes.

# Transformation
Process of transformation basic graph into our working graph. This is very easy process but needed for simplicity of previous building process - possibly will leave this out and choose to transform the graph while building it. There are 2 pulic methods. `transformGraph` which transforms our graph into working graph as it is and `transformTransposeGraph` which does the same but with reversed edges.

# Graph algorithms
`getTopoOnScc` - takes Basic graph from our parsing and returns List of `StrongComponent` in it.
`sortComponentsTopology` - takes List of `StrongComponent` and sorts components so that components in same depth are next to each other.
`predecessors` - takes a hero node and List of nodes and returns List of Nodes which are parents - or predeccesors- to this hero node.
`heightOfNet` - takes List of `StrongComponent` and returns height of Petri net needed for it to be visualised.
`wifthOfNet` - same as heightOfNet but its all about width.
      **Strong Component** : class representing strong components in graph - group of nodes where its possible to get from every node to every node contained under given strong component. This contains List of Nodes contained in the given strong component, Nodes coming in and out of strong component, flag which is just for our convenience and easier work and depth which says how deep in net this component is in topological order.
      
# UI
Very basic version contains 2 buttons - for browsing files opening file dialog and second for visualisation of choosen .dot file. TextBlock for Preview of file, TextBlock for showing the location of file andan empty canvas which is currently unused. Everythin under the Grid. Visualisation is opened on new Window containing Canvas on which we draw shapes (ellipses and rectangles corresponding to nodes and transitions, lines and polygons corresponding to edges) - everything for visualisation of graph is written under `MainWindowViewModel.cs` where I just call methods for generating the xaml from `visualisation/MainCanvasWork.cs` Each Node and Transition is represented by class `CanvasNode` as only difference is their shape. `CanvasNode` is made up from the actual Shape and TextBlock on top of it for visualising its name/description. It has also width and height of actual node, `portIn` and `portOut` representing where edges are about to connect and actual Node coresponding to it. 
